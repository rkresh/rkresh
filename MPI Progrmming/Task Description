Laplace equation inversion 
Introduction 
In this assignment, we will build on top of our work from the previous assignment. Previously, we built a Laplace equation solver that can go from initial conditions to the steady-state solution. For details on that, please refer to the instruction document on CA2 and your own submission for it. In many areas of science and engineering, we have equations to describe the behaviour of a system, where, given a set of initial conditions and system parameters, the equation can describe the behaviour of the system at steady-state or as a function of time. These equations are usually partial differential equations (PDEs), and PDE-based simulations of such systems are a primary driver of high-performance computing research. In CA2 previously, we saw an example where we used the Laplace equation (a PDE), to calculate the steady-state temperature distribution of a room.  

Inverse Problems 
In real-life problems, it is often the case that the parameters of the system are harder to measure than the final observations. For example, when studying wave propagation through a medium, it is easier to record the received signal than it is to measure the speed of sound at every point in the medium. Sometimes our interest is in finding out what initial conditions would lead to a desired final state. These are both examples of inverse problems - where we are solving for the inputs to a PDE, already knowing the output, essentially solving the PDE in reverse (although, as you will see, we are not literally reversing the PDE). As computer systems get faster and bigger, the utility of inverse problems is rapidly rising, especially in the last decade. It is common to see inverse problems in Astrophysics (predicting gravitational waves), Geophysics (understanding earthquakes, tsunamis), Computational imaging (making images of the human brain, or of inside the earth), and also in computational design (what shape of a car produces the maximum amount of downforce while meeting a prescribed weight target?) 

In this assessment, we will solve an inverse version of the problem from CA2. Instead of solving the Laplace equation for a given set of initial conditions, we will invert for the initial conditions, knowing the steady-state distribution. Most realistic inverse problems are solved using gradient-based methods, which is out of scope for our module (but feel free to read about it in your time). Here we will carry out the inversion using a modified version of the bisection method.   

Bisection method 
The Bisection method (also called bisection search) is a very old and well-studied method for finding roots of a smooth, continuous function when given an interval within which at least one root lies.   

How we will use the bisection method 
The bisection method evaluates the function (which is the Laplace equation solver from CA2) once per iteration and reduces the interval in which the solution lies by a factor of 2. This method can be extended to an n-section method where we can choose to break the interval down into more than just two sections. If we can evaluate the function n times per iteration, we can reduce the interval by a factor of n + 1, speeding up convergence. 
Running over MPI, we can set n to be the number of ranks. At every iteration, every rank runs an instance of your Laplace equation solver from CA2, with a slightly different value of the radiator temperature. At the end of the Laplace equation solve, you get the final temperatures for each of the different radiator temperatures. Use this to decide the interval to be explored in the next iteration, continuing until the interval is as small as machine epsilon or until a maximum of 1000 iterations. 
Having done this, you would have written a program that uses both MPI and OpenMP together. I hope you are proud of yourself.   

Problem specifications 
N = 1024, K = 100000. Wall temperatures at 10◦C. a0 = 10, b0 = 5000. Target temperature at the middle (5.0, 5.0) of the room should be 37◦C.     
