Laplace equation solver
In this assignment, we will build a solver for the Laplace equation, which is a second-order Partial Differential Equation that appears in many areas of science and Engineering including electricity, fluid flow, and steady state heat conduction. Here we will use the equation to model the steady state heat distribution in a room with a radiator. Although a real room is three dimensional, we will limit this exercise to two dimensions for simplicity. The room is 10 by 10m with a radiator along one wall as shown in Figure 1. The radiator is 4m wide and is centred along the wall, i.e. it takes up 40% of the wall, with 30% on either side. The radiator is held at a constant temperature of 100◦C. The walls are all at 10◦C. Together this specifies the temperature at every point at the boundaries of our domain (the room). Boundary conditions specified in this way are called Dirichlet boundary conditions

This problem is a stencil computation. The temperature value at every point can be calculated by averaging the temperature of its four neighbouring points. This might remind you of something we studied in class - this is the famous stencil pattern (or a gather access), where every value in an array is calculated as a weighted sum of the points in its vicinity. This stencil is a simple one where the weights are the same. The example we saw in class was a one-dimensional stencil so each point had two neighbours. However, since this is a two-dimensional physical problem, instead of two neighbours, every point now has four neighbours. If we were to extend this problem to three dimensions (we will NOT do that here), every point would have six neighbours (two for each dimension). To simplify things, we will consider the points along the edge of our domain, i.e. where i = 0, j = 0, i = n, or j = n, to represent the walls, or the radiator. We will refer to these as the boundary points. All the points in the domain that are not boundary points will be called interior points, i.e.  for 0 < i < n, 0 < j < n. In total there are (n + 1)2 points, of which (n − 1)2 are interior points while the rest are boundary points. The temperature of the boundary points will be considered fixed. The temperature of the interior points will be calculated by using the formula given in Equation 2 iteratively until a given maximum number of iterations or when the temperature between successive iterations does not change by at least a given amount (whichever happens first).

Task 1: Sequential Program
The given code can be improved by avoiding the data copying loop at the end of each iteration. This can be achieved by defining t as a three-dimensional array of size 2 ×(N + 1)×(N + 1), i.e. t[x][ i ][ j ]. Every iteration can then swap between reading from x=0 and writing to x=1, and vice-versa. For example, the first iteration could read from t [0][ i ][ j ] and write to t [1][ i ][ j ], while the second iteration could read from t [1][ i ][ j ] (which was just written in the previous iteration) and write to t [0][ i ][ j ] (overwriting the initial values since they are no longer required), and the third iteration would repeat what the first one did. Rewrite the given code to implement the above change to remove the extra data copy. Write a complete C program that models the temperature distribution of the room given in Figure 1. Your domain should consist of N × N points and you should solve to K iterations where N and K are defined constants in your code (so you can change them easily). Instrument the code to track the total time taken and display it in the end of the execution. Also display the final temperature at every N/8×N/8 points in your domain, i.e. 8 ×8 points, regardless of the value of N. Use smaller values of N and K while developing and testing your code, but your submission should have N = 1024 and K = 100000.

Task 2: OpenMP program
Modify the sequential program from Task 1 to be an OpenMP program. This program should start by solving the problem in serial (using the same code from Task 1), then it should solve
the problem in parallel using OpenMP. It should also have code to check that the results do not change between the two invocations. Finally, measure the time for both versions, calculate and report both the times and the speedup achieved.
